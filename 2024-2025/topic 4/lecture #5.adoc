:toc:
:toclevels: 3

= Функции и модули

== Функции

*Функции* — это многократно используемые фрагменты программы. Они позволяют
дать имя определённому блоку команд с тем, чтобы впоследствии запускать этот блок по указанному имени в любом месте программы и сколь угодно много раз. Это называется вызовом функции. 

Функции определяются при помощи зарезервированного слова def. После этого слова указывается имя функции, за которым следует пара скобок, в которых можно указать имена некоторых переменных, и заключительное двоеточие в конце строки. Далее следует блок команд, составляющих функцию. 
На примере можно видеть, что на самом деле это очень просто:

```python
def sayHello():
    print('Привет, Мир!') # блок, принадлежащий функции
# Конец функции

sayHello() # вызов функции
sayHello() # ещё один вызов функции
---------
Привет, Мир!
Привет, Мир!
```

Мы определили функцию с именем `sayHello`, используя описанный выше синтаксис. Эта функция не принимает параметров, поэтому в скобках не объявлены какие-либо переменные. Параметры функции — это некие входные данные, которые мы можем передать функции, чтобы получить соответствующий им результат.

=== Параметры функцции
Функции могут принимать параметры, т. е. некоторые значения, передаваемые функции для того, чтобы она что-либо сделала с ними. Эти параметры похожи на переменные, за исключением того, что значение этих переменных указывается при вызове функции, и во время работы функции им уже присвоены их значения.

Параметры указываются в скобках при объявлении функции и разделяются запятыми. Аналогично мы передаём значения, когда вызываем функцию. Обратите внимание на терминологию: имена, указанные в объявлении функции, называются параметрами, тогда как значения, которые вы передаёте в функцию при её вызове, - аргументами.

```python
def printMax(a, b):
    if a > b:
        print(a, 'максимально')
    elif a == b:
        print(a, 'равно', b)
    else:
        print(b, 'максимально')

printMax(3, 4) # прямая передача значений

x = 5
y = 7

printMax(x, y) # передача переменных в качестве аргументов
```
=== Возврат значения из функции
Функции могут возвращать значения с помощью оператора `return`.

```python
def add(a, b):
    return a + b

result = add(3, 5)
print(result)  # Вывод: 8
```
```python
def add(a, b):
    print(a + b) # Вывод: 8

result = add(3, 5)
```

=== Переменные

*Локальные переменные* 

При объявлении переменных внутри определения функции, они никоим образом не связаны с другими переменными с таким же именем за пределами функции — т. е. имена переменных являются локальными в функции. Это называется областью видимости переменной. Область видимости всех переменных ограничена блоком, в котором они объявлены, начиная с точки объявления имени.

```python
x = 50

def func(x):
    print('x равен', x)
    x = 2
    print('Замена локального x на', x)

func(x)
print('x по-прежнему', x)
--------------------------
x равен 50
Замена локального x на 2
x по-прежнему 50
```

При первом выводе значения, присвоенного имени x, в первой строке функции Python использует значение параметра, объявленного в основном блоке, выше определения функции.

Далее мы назначаем x значение 2. Имя x локально для нашей функции. Поэтому когда мы заменяем значение x в функции, x, объявленный в основном блоке, остаётся незатронутым.

Последним вызовом функции print мы выводим значение x, указанное в основном блоке, подтверждая таким образом, что оно не изменилось при локальном присваивании значения в ранее вызванной функции.

*Зарезервированное слово "global"*

Чтобы присвоить некоторое значение переменной, определённой на высшем уровне программы (т. е. не в какой-либо области видимости, как то функции или классы), необходимо указать Python, что её имя не локально, а глобально (`global`). Выполняется это при помощи зарезервированного слова ё. Без применения зарезервированного слова global невозможно присвоить значение переменной, определённой за пределами функции.

Можно использовать уже существующие значения переменных, определённых за пределами функции (при условии, что внутри функции не было объявлено переменной с таким же именем). Однако, это не приветствуется, и его следует избегать, поскольку человеку, читающему текст программы, будет непонятно, где находится объявление переменной. Использование зарезервированного слова global достаточно ясно показывает, что переменная объявлена в самом внешнем блоке.

```python
x = 50

def func():
    global x

    print('x равно', x)
    x = 2
    print('Заменяем глобальное значение x на', x)

func()
print('Значение x составляет', x)
--------------------------
x равно 50
Заменяем глобальное значение x на 2
Значение x составляет 2
```

Зарезервированное слово `global` используется для того, чтобы объявить, что `x` — это глобальная переменная, а значит, когда мы присваиваем значение имени `x` внутри функции, это изменение отразится на значении переменной `x` в основном блоке программы.

Используя одно зарезервированное слово `global`, можно объявить сразу несколько переменных: `global x, y, z`.

=== Аргументы

*Значения аргументов по умолчанию*

Зачастую часть параметров функций могут быть необязательными, и для них будут использоваться некоторые заданные значения по умолчанию, если пользователь не укажет собственных. Этого можно достичь с помощью значений аргументов по умолчанию. Их можно указать, добавив к имени параметра в определении функции оператор присваивания (=) с последующим значением.

```python
def greet(name="Guest"):
    print(f"Hello, {name}!")

greet()       # Вывод: Hello, Guest!
greet("Bob")  # Вывод: Hello, Bob!
```

*Ключевые аргументы*

Если имеется некоторая функция с большим числом параметров, и при её вызове требуется указать только некоторые из них, значения этих параметров могут задаваться по их имени — это называется ключевые параметры. В этом случае для передачи аргументов функции используется имя (ключ) вместо позиции (как было до сих пор).

Есть два преимущества такого подхода: во-первых, использование функции становится легче, поскольку нет необходимости отслеживать порядок аргументов; во-вторых, можно задавать значения только некоторым избранным аргументам, при условии, что остальные параметры имеют значения аргумента по умолчанию.

```python
def func(a, b=5, c=10):
    print('a равно', a, ', b равно', b, ', а c равно', c)

func(3, 7)
func(25, c=24)
func(c=50, a=100)
--------------------------
a равно 3, b равно 7, а c равно 10
a равно 25, b равно 5, а c равно 24
a равно 100, b равно 5, а c равно 50
```

*Переменное число параметров*

Иногда бывает нужно определить функцию, способную принимать любое число параметров. Этого можно достичь при помощи звёздочек.

```python
def total(a=5, *numbers, **phonebook):
    print('a', a)

    #проход по всем элементам кортежа
    for single_item in numbers:
        print('single_item', single_item)

    #проход по всем элементам словаря
    for first_part, second_part in phonebook.items():
        print(first_part,second_part)

print(total(10,1,2,3,Jack=1123,John=2231,Inge=1560))
--------------------------
a 10
single_item 1
single_item 2
single_item 3
Inge 1560
John 2231
Jack 1123
None
```

*Как это работает:*

Когда мы объявляем параметр со звёздочкой (например, `\*param`), все позиционные аргументы начиная с этой позиции и до конца будут собраны в кортеж под именем `param`.
Аналогично, когда мы объявляем параметры с двумя звёздочками (`**param`), все ключевые аргументы начиная с этой позиции и до конца будут собраны в словарь под именем `param`.

=== Анонимные функции (lambda-функции)
lambda-функции — это небольшие анонимные функции, которые можно определить без использования def. Они используются для простых операций.
```python
# Пример lambda-функции
add = lambda x, y: x + y
print(add(3, 5))  # Вывод: 8
```

Lambda-функции часто используются для работы с функциями высшего порядка, такими как `map()`, `filter()`, и `sorted()`.

=== Рекурсивная функция

*Рекурсия* — это метод, при котором функция вызывает саму себя. Он позволяет решать задачи, которые можно разбить на подзадачи того же типа. Рекурсивные функции особенно полезны для задач, требующих повторяющихся вычислений, но с изменяющимися параметрами, как например, задачи на вычисление факториала, числа Фибоначчи и задачи, связанные с обходом деревьев и графов.

```python
def factorial_recursive(n):
    if n == 1:
        return n
    else:
        return n*factorial_recursive(n-1)

num = 3
print(f"Факториал {num} это {factorial_recursive(num)}")
```

Вызывая рекурсивную функцию здесь и передавая ей целое число, вы получаете факториал этого числа (n!).
Факториал числа — это число, умноженное на каждое предыдущее число вплоть до 1.

По аналогии с обычной функцией имя рекурсивной указывается после `def`, а в скобках обозначается параметр `n`:

```python
def factorial_recursive(n):
    if n == 1:
        return n
    else:
        return n*factorial_recursive(n-1)
```

Благодаря условной конструкции переменная `n` вернется только в том случае, если ее значение будет равно 1. Это еще называют условием завершения. Рекурсия останавливается в момент удовлетворения условиям.
В блоке `else` условной конструкции возвращается произведение `n` и значения этой же функции с параметром `n-1`.
Это и есть рекурсия. В нашем примере это так сработало: `3 * (3-1) * ((3-1)-1)  # так как 3-1-1 равно 1, рекурсия остановилась`

Чтобы еще лучше понять, как это работает, разобьем на этапы процесс выполнения функции с параметром 3.

Для этого ниже представим каждый экземпляр с реальными числами. Это поможет «отследить», что происходит при вызове одной функции со значением 3 в качестве аргумента:

```python
# Первый вызов
factorial_recursive(3):
    if 3 == 1:
        return 3
    else:
        return 3*factorial_recursive(3-1)

# Второй вызов
factorial_recursive(2):
    if 2 == 1:
        return 2
    else:
        return 2*factorial_recursive(2-1)

# Третий вызов
factorial_recursive(1):
    if 1 == 1:
        return 1
    else:
        return 1*factorial_recursive(1-1)
```

Рекурсивная функция не знает ответа для выражения `3*factorial_recursive(3–1)`, поэтому она добавляет в стек еще один вызов.

*Рекурсивно или итеративно?*

Каковы же преимущества рекурсивных функций? Можно ли с помощью итеративных получить тот же результат? Когда лучше использовать одни, а когда — другие?

Важно учитывать временную и пространственную сложности. Рекурсивные функции занимают больше места в памяти по сравнению с итеративными из-за постоянного добавления новых слоев в стек в памяти. Однако их производительность куда выше.

Тем не менее рекурсия может быть медленной, если ее неправильно реализовать. Из-за этого вычисления будут происходить чаще, чем требуется.

Написание итеративных функций зачастую требуется большего количества кода. Например, дальше пример функции для вычисления факториала, но с итеративным подходом. Выглядит не так изящно, не правда ли?

== Модули

*Модули* - это файлы Python с расширением .py, которые содержат функции, классы и переменные, позволяющие организовать код и сделать его более удобным для повторного использования.

Чтобы использовать модуль в Python, его нужно импортировать с помощью `import`.

```python
# Импортирование стандартного модуля math
import math

# Использование функции из модуля
print(math.sqrt(16))  # Вывод: 4.0
```

Можно импортировать конкретные функции из модуля с помощью `from ... import ...`.
```python
from math import sqrt

print(sqrt(25))  # Вывод: 5.0
```

Можно задавать псевдонимы для импортированных модулей, что особенно полезно для длинных названий.
```python
import math as m

print(m.sqrt(36))  # Вывод: 6.0
```

*Создание и использование собственного модуля*

Создадим модуль my_module.py и определим в нём простую функцию.

```python
# my_module.py

def greet(name):
    print(f"Hello, {name}!")
```

Теперь этот модуль можно использовать в других программах, импортировав его:
```python
import my_module

my_module.greet("Alice")  # Вывод: Hello, Alice!
```
