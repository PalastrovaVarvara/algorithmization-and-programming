:toc:
:toclevels: 3

= Структуры данных

Структуры данных - это структуры, которые могут хранить некоторые данные вместе. Они используются для хранения связанных данных.
B Python существуют четыре встроенных структуры данных:

* список,
* кортеж,
* словарь,
* множество.

== Списки

Большинство программ работает не отдельными переменными, a с набором переменных.
Например, программа может обрабатывать информацию об учащихся класса, считывая список учащихся с клавиатуры илиз файла, при этом изменение количества учащихся в классе не должно требовать модификации исходного кода программы.

*Список* - это упорядоченные коллекции элементов, которые могут содержать данные любого типа. Они аналогичны массивам в других языках программирования, но обладают большей гибкостью. Списки позволяют добавлять, удалять и изменять элементы, что делает их очень удобными для работы с динамическими данными.
Список можно задать перечислением элементов списка в квадратных скобках, например, список можно задать так:

`Primes = [2, 3, 5, 7, 11, 13]`

`Rainbow = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Indigo', 'Violet']`

В списке Primes - 6 элементов, а cписок Rainbow состоит из 7 элементов, каждый из которых является строкой.

Также как и символы строки, элементы списка можно индексировать отрицательными числами с конца, например, `Primes[-1] == 13`, `Primes[-6] == 2`.
Длину списка, то есть количество элементов в нем, можно узнать при помощи функции len, например, `len(A) == 6`.

Можно создать пустой список (не содержащий элементов, длины 0), в конец списка можно добавлять элементы при помощи метода append. Например, если программа получает на вход количество
элементов в списке п, а потом элементов списка по одному в отдельной строке, торганизовать считывание списка можно так:
```python
A = []
for i in range(int(input()):
A.append(int(input())
```

в этом примере создается пустой список, далее считывается количество элементов в списке, затем по одному считываются элементы списка добавляются в его конец.

Вывести элементы списка можно одной инструкцией `print(A)`, при этом будут выведены квадратные скобки вокруг элементов списка и запятые между элементами списка.
Такой вывод неудобен, чаще требуется просто вывести все элементы списка в одну строку или по одному элементу в строке. Приведем два примера, отличающиеся организацией цикла:

```python
for i in range(len(A)):
print(A[i])
```

Здесь в цикле меняется индекс элемента i, затем выводится элемент списка с индексом i.

```python
for elem in A:
print(elem, end = '')
```

В этом примере элементы списка выводятся в одну строку, разделенные пробелом, при этом в цикле меняется не индекс элемента списка, а само значение переменной
Например, в цикле `for elem in ['red', 'green', 'blue']` переменная elem будет последовательно принимать значения 'red', 'green', 'blue'.

=== Методы split и join

Элементы списка могут вводиться по одному в строке, в этом случае строку можно считать функцией `input()`. После этого можно использовать метод строки `split`, возвращающий список строк, разрезав исходную строку на части по пробелам.

`A = input().split()` 

Если при запуске этой программы ввести строку 1 2 3, то список А будет равен `['1', '2', '3']` - список будет состоять из строк, а не из чисел.
Если хочется получить список именно из чисел, то можно затем элементы списка по одному преобразовать в числа:

```python
for i in range(len(A)):
A[i] = int(A[i])
```
Используя функции языка `map` и `list` то же самое можно сделать в одну строку:
`A = list(map(int, input().split()))`
Если нужно считать список действительных чисел, то нужно заменить тип `int` на тип `float`.

У метода `split` есть необязательный параметр, который определяет, какая строка будет использоваться в качестве разделителя между элементами списка.
Например, метод `split('.')` вернет список, полученный разрезанием исходной строки по символам.
Используя "обратные" методы можно вывести список при помощи однострочной команды.
Для этого используется метод строки join. У этого метода один параметр: список строк.
B результате получается строка, полученная соединением элементов списка (которые переданы в качестве параметра) в одну строку, при этом между элементами списка вставляется
разделитель, равный той строке, к которой применяется метод.
Например программа
```python
A = ['red', 'green', 'blue']
print(".join(A))
print(".join(A))
print('***'.join(A))

'red green blue'
redgreenblue 
red***green***blue
```
Если же список состоит из чисел, то придется использовать еще и функцию map. То есть вывести элементы списка чисел, разделяя их пробелами, можно так:
`print(' '.join(map(str, A)))`

== Кортеж

Кортежи - это упорядоченные коллекции элементов, которые, в отличие от списков, являются неизменяемыми. Они полезны для хранения данных, которые не должны изменяться в ходе выполнения программы. Кортежи могут быть использованы в качестве ключей в словарях, что невозможно для списков.

```python
zoo = ('питон', 'слон', 'пингвин') # помните, что скобки не обязательны
print('Количество животных в зоопарке -', len(zoo))

new_zoo = 'обезьяна', 'верблюд', zoo
print('Количество клеток в зоопарке -', len(new_zoo))
print('Все животные в новом зоопарке:', new_zoo)
print('Животные, привезённые из старого зоопарка:', new_zoo[2])
print('Последнее животное, привезённое из старого зоопарка -', new_zoo[2][2])
print('Количество животных в новом зоопарке -', len(new_zoo)-1+len(new_zoo[2]))
Вывод:
Количество животных в зоопарке - 3
Количество клеток в зоопарке - 3
Все животные в новом зоопарке: ('обезьяна', 'верблюд', ('питон', 'слон','пингвин'))
Животные, привезённые из старого зоопарка: ('питон', 'слон', 'пингвин')
Последнее животное, привезённое из старого зоопарка - пингвин
Количество животных в новом зоопарке - 5
```

Пустой кортеж создаётся при помощи пустой пары скобок - `"myempty = ()"`.
Однако, с кортежем из одного элемента не всё так просто. Его нужно указывать при помощи запятой после первого (и единственного) элемента, чтобы Python мог отличить кортеж от скобок, окружающихобъект в выражении.
Таким образом, чтобы получить кортеж, содержащий
элемент 2, вам потребуется указать `"singleton = (2,)"`.

== Списки

Обычные списки (массивы) представляют собой набор пронумерованных элементов, то есть для обращения к какому-либо элементу списка необходимо указать его номер. Номер элемента в списке однозначно идентифицирует сам элемент. Но идентифицировать данные по числовым номерам не всегда оказывается удобно.
Например, маршруты поездов в России идентифицируются численно-буквенным кодом (число и одна цифра), также численно-буквенным кодом идентифицируются авиарейсы, то есть для хранения
информации о рейсах поездов или самолетов в качестве идентификатора удобно было использовать не число, а текстовую строку.
Структура данных, позволяющая идентифицировать ee элементы не по числовому индексу, по произвольному, называется словарем или ассоциативным массивом.
Соответствующая структура данных в python языке называется `dict`.
Рассмотрим простой пример использования словаря. Заведем словарь Capitals, где индексом является название страны, а
значением - название столицы этой страны. Это позволит легко определять по строке с названием страны ее столицу.
```python
# Создадим пустой словарь Capitals
Capitals = dict()
# Заполним его несколькими значениями
Capitals['Russia'] = 'Moscow'
Capitals['Ukraine'] = 'Kiev'
Capitals['USA'] = 'Washington'
# Считаем название страны
print('В какой стране вы живете?')
country = input()
# Проверим, есть ли такая страна в словаре Capitals
if country in Capitals:
# Если есть - выведем ее столицу
print('Столица вашей страны', Capitals[country])
else:
# Запросим название столицы и добавив его в словарь
print('Как называется столица вашей страны?')
city = input()
Capitals[country] = city
```
Итак, каждый элемент словаря состоит из двух объектов: ключа и значения. В нашем примере ключом является название страны, значением является название
столицы. Ключ идентифицирует элемент словаря, значение является данными, которые соответствуют данному ключу.
Значения ключей - уникальны, двух одинаковых ключей в словаре быть не может.
B жизни широко распространены словари, например, привычные бумажные словари (толковые, орфографические, лингвистические).
В них ключом является слово-заголовок статьи, а значением - сама статья. Для того, чтобы получить доступ к статье, необходимо указать слово-ключ.

Другой пример словаря - телефонный справочник. В нем ключом является имя, а значением - номер телефона. И словарь, и телефонный справочник хранятся так, что легко найти
элемент словаря по известному ключу (например, если записи хранятся в алфавитном порядке ключей, то легко можно найти известный ключ, например, бинарным поиском), но если ключ
неизвествен, а известно лишь значение, то поиск элемента с данным значением может потребовать последовательного просмотра всех элементов словаря.
Особенностью фссоциативного массива является динамичность: в него можно добавлять новые элементы с произвольными ключами и удалять уже существующие
элементы. При этом размер памяти пропорционален размеру ассоциативного массива. Доступ к элементам ассоциативного массива выполняется хоть и
медленнее, чем к обычным массивам, но в целом довольно быстро.
Ключом может быть произвольный неизменяемый тип данных:

* целые и действительные числа,
* строки,
* кортежи.

Ключом в словаре не может быть множество, но может быть элемент типа `frozenset`: специальный тип данных, являющийся аналогом типа set, который нельзя
изменять после создания.
Значением элемента словаря может быть любой тип данных, в том числе и изменяемый.

=== Когда нужно использовать словари

* Подсчет числа каких-то объектов. В этом случае нужно завести
словарь, в котором ключами являются объекты, а значениями - их количество.
* Хранение каких-либо данных, связанных с объектом. Ключи - объекты, значения - связанные с ними данных. Например, если нужно по названию месяца определить его порядковый
номер, то это можно сделать при помощи словаря `Num['January'] = 1; Num['February'] = 2`
* Установка соответствия между объектами (например, "родитель-потомок"). Ключ - объект, значение - соответствующий ему объект.
* Если нужен обычный массив, но при этом масимальное значение индекса элемента очень велико, но при этом будут использоваться не все возможные индексы (так называемый "разреженный массив"), то можно использовать ассоциативный массив для экономии памяти.

Пустой словарь можно создать при помощи функции `dict()` или пустой пары фигурных скобок `[]` (вот почему фигурные скобки нельзя использовать для создания пустого множества). Для
создания словаря с некоторым набором начальных значений можно использовать следующие конструкции:
```python
Capitals = {'Russia': 'Moscow', 'Ukraine': 'Kiev', 'USA': 'Washington'}
Capitals = dict(Russia = 'Moscow', Ukraine = 'Kiev', USA = 'Washington')
Capitals = dict([("Russia", "Moscow"), ("Ukraine", "Kiev"), ("USA", "Washington")])
Capitals = dict(zip(["Russia", "Ukraine", "USA"], ["Moscow", "Kiev", "Washington"]))
```

Основная операция: получение значения элемента по ключу, записывается так же, как и для списков: `A[key]`.
Если элемента с заданным ключом не существует в словаре, то возникает исключение `KeyError`.
Другой способ определения значения по ключу - метод get: `A. get(key)`.
Если элемента с ключом get нет в словаре, то возвращается значение `None`.
В форме записи с двумя аргументами `A.get(key, val)` метод возвращает значение val, если элемент ключом `key` отсутствует в словаре.
Проверить принадлежность элемента словарю можно операциями `in` и `not in`, как и для множеств.

Для добавления нового элемента в словарь нужно просто присвоить ему какое-то значение: `A[key] = value`.
Для удаления элемента из словаря можно использовать операцию `del A[key]` 

Еще один способ удалить элемент из словаря: использование метода `рор`: `A.pop(key)`.
Этот метод возвращает значение удаляемого элемента, если элемент с данным ключом отсутствует в словаре, то возникает исключение.
Если методу `рор` передать второй параметр, то если элемент словаре отсутствует, метод `рор` вернет значение этого параметра.
Это позволяет проще всего организовать безопасное удаление элемента из словаря: `A.pop(key, None)`.

Можно легко организовать перебор ключей всех элементов в словаре: `for key in A: print(key, A[key])`

Следующие методы возвращают представления элементов словаря. Представления во многом похожи на множества, но они изменяются, если менять значения элементов словаря.
Метод `keys` возвращает представление ключей всех элементов, метод `values` возвращает представление всех значений, а метод `items` возвращает представление всех пар
(кортежей) из ключей и значений.

Соответственно, быстро проверить, если ли значение `val` среди всех значений элементов словаря `А` можно так: `val in A.values()`, а организовать цикл так, чтобы в переменной `key` был ключ элемента, а в переменной val было его значение можно так:
```python
for key, val in A.items():
print(key, val)
```

== Множества 

Множество  - это неупорядоченные коллекции уникальных элементов. Они полезны для выполнения операций над множествами, таких как объединение, пересечение и разность. Множества автоматически удаляют дублирующиеся элементы, что делает их идеальными для задач, связанных с уникальными значениями.

B отличии от массивов, где элементы хранятся в виде последовательного списка, в множествах порядок хранения элементов неопределен. Это позволяет выполнять операции типа
проверить принадлежность элемента множеству быстрее, чем просто перебирая все элементы множества.
Элементами множества может быть любой неизменяемый тип данных: числа, строки, кортежи.
Изменяемые типы данных не могут быть элементами множества, в частности, нельзя сделать элементом
множества список (но можно сделать кортеж) или другое множество.
Требование неизменяемости элементов множества накладывается особенностями представления множества в памяти компьютера.

Множество задается перечислением всех его элементов в фигурных скобках. Например: `A = {1, 2,3}`
Исключением является пустое множество, которое можно создать при помощи функции `set()`.
Если функции set передать в качестве параметра список, строку или кортеж, то она вернет множество, составленное из элементов списка, строки, кортежа.
Например:  `A = set('qwerty') print(A)` выведет `{'e', 'q', 'r', 't', 'w', 'y'}`.

Каждый элемент может входить в множество только один раз, порядок задания элементов не важен.
Например, программа: 
```python
A = (1, 2, 3) B = (3, 2, 3, 1)
print(A == B)
```
выведет `True`, так как А и В - равные множества.
Каждый элемент может входить в множество только один раз, `set('Hello')` вернет множество из четырех элементов: `{'H', 'e', 'I', 'o'}`.

Узнать число элементов в множестве можно при помощи функции `len`.
Перебрать все элементы множества (в неопределенном порядке!) можно при помощи цикла `for`:
```python
C = {1, 2, 3, 4, 5}
for elem in C:
print(elem)
```

Для добавления элемента в множество есть метод `add`: `A.add(x)`
Для удаления элемента х из множества есть два метода: `discard` и `remove`. Их поведение различается только в случае, когда удаляемый элемент отсутствует в множестве. В
этом случае метод `discard` не делает ничего, а метод `remove` генерирует исключение KeyError.
Метод `рор` удаляет из множества один случайный элемент и возвращает его значение. Если же множество пусто, то генерируется исключение `KeyError`.
Из множества можно сделать список при помощи функции `list`.

При помощи цикла `for` можно перебрать все элементы множества:
```python
Primes = [2, 3, 5, 7, 11]
for num im Primes:
print(num)
```










